# Cursor Rules for ASMIS Backend Project

# 1. Environment & Security Standards
rule "Use python-dotenv for environment variables" {
    pattern: "from dotenv import load_dotenv"
    message: "Always use python-dotenv for environment variable management"
    example: """
    from dotenv import load_dotenv
    import os
    
    load_dotenv()
    api_key = os.getenv("API_KEY")
    """
}

rule "No hardcoded secrets" {
    pattern: "(?i)(password|secret|key|token)\\s*=\\s*['\"].*['\"]"
    message: "Never hardcode secrets or API keys in code"
    example: """
    # BAD:
    api_key = "sk-123456789"
    
    # GOOD:
    api_key = os.getenv("API_KEY")
    """
}

rule "Validate environment variables" {
    pattern: "def validate_env_vars"
    message: "Implement environment variable validation on startup"
    example: """
    def validate_env_vars():
        required_vars = ["API_KEY", "DATABASE_URL"]
        missing = [var for var in required_vars if not os.getenv(var)]
        if missing:
            raise EnvironmentError(f"Missing required environment variables: {', '.join(missing)}")
    """
}

# 2. Code Quality Standards
rule "Type hints required" {
    pattern: "def [a-zA-Z_][a-zA-Z0-9_]*\\([^)]*\\):"
    message: "All functions must have type hints"
    example: """
    def process_data(data: Dict[str, Any], config: Optional[Config] = None) -> List[Result]:
        pass
    """
}

rule "Error handling" {
    pattern: "try:"
    message: "Implement comprehensive error handling"
    example: """
    try:
        result = process_data(data)
    except ValueError as e:
        logger.error(f"Invalid data format: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise
    """
}

rule "Documentation" {
    pattern: "def [a-zA-Z_][a-zA-Z0-9_]*\\([^)]*\\):"
    message: "All functions must have docstrings"
    example: """
    def process_data(data: Dict[str, Any]) -> List[Result]:
        \"\"\"
        Process the input data and return results.
        
        Args:
            data: Dictionary containing input data
            
        Returns:
            List of processed results
            
        Raises:
            ValueError: If data format is invalid
        \"\"\"
        pass
    """
}

# 3. Full-Stack Best Practices
rule "RESTful API patterns" {
    pattern: "@app.route"
    message: "Follow RESTful API design patterns"
    example: """
    @app.route("/api/v1/resources/<resource_id>", methods=["GET"])
    def get_resource(resource_id: str) -> Response:
        try:
            resource = Resource.get(resource_id)
            return jsonify(resource.to_dict()), 200
        except ResourceNotFound:
            return jsonify({"error": "Resource not found"}), 404
    """
}

rule "Database connection pooling" {
    pattern: "create_engine"
    message: "Use connection pooling for database connections"
    example: """
    engine = create_engine(
        DATABASE_URL,
        pool_size=5,
        max_overflow=10,
        pool_timeout=30,
        pool_recycle=1800
    )
    """
}

rule "Logging" {
    pattern: "import logging"
    message: "Implement proper logging"
    example: """
    import logging
    
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    """
}

# 4. AI/ML Integration
rule "Structured prompts" {
    pattern: "class.*Prompt"
    message: "Use structured prompt templates"
    example: """
    class SalesPrompt:
        def __init__(self, context: Dict[str, Any]):
            self.context = context
            
        def format(self) -> str:
            return f\"\"\"
            Analyze the following sales opportunity:
            Customer: {self.context['customer']}
            Product: {self.context['product']}
            Value: {self.context['value']}
            
            Provide insights on:
            1. Competitive positioning
            2. Risk factors
            3. Recommended actions
            \"\"\"
    """
}

rule "Token counting" {
    pattern: "def count_tokens"
    message: "Implement token counting for AI requests"
    example: """
    def count_tokens(text: str, model: str = "gpt-4") -> int:
        \"\"\"
        Count tokens in text for the specified model.
        
        Args:
            text: Input text to count
            model: Model to count tokens for
            
        Returns:
            Number of tokens
        \"\"\"
        try:
            response = openai.Tokenizer.count_tokens(text, model)
            return response.usage.total_tokens
        except Exception as e:
            logger.error(f"Error counting tokens: {e}")
            return 0
    """
}

rule "Rate limiting" {
    pattern: "class.*RateLimiter"
    message: "Implement rate limiting for external APIs"
    example: """
    class RateLimiter:
        def __init__(self, max_requests: int, time_window: int):
            self.max_requests = max_requests
            self.time_window = time_window
            self.requests = []
            
        def can_make_request(self) -> bool:
            now = time.time()
            self.requests = [req for req in self.requests if now - req < self.time_window]
            return len(self.requests) < self.max_requests
    """
}

# 5. Production Readiness
rule "Docker configuration" {
    pattern: "Dockerfile"
    message: "Include Docker configuration"
    example: """
    FROM python:3.9-slim
    
    WORKDIR /app
    
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    COPY . .
    
    ENV PYTHONPATH=/app
    
    CMD ["python", "main.py"]
    """
}

rule "Health checks" {
    pattern: "@app.route.*health"
    message: "Implement health check endpoints"
    example: """
    @app.route("/health", methods=["GET"])
    def health_check() -> Response:
        try:
            # Check database connection
            db.session.execute("SELECT 1")
            
            # Check external services
            services_status = check_external_services()
            
            return jsonify({
                "status": "healthy",
                "services": services_status
            }), 200
        except Exception as e:
            return jsonify({
                "status": "unhealthy",
                "error": str(e)
            }), 500
    """
}

rule "Security headers" {
    pattern: "app.config"
    message: "Implement security headers"
    example: """
    from flask_talisman import Talisman
    
    app = Flask(__name__)
    Talisman(app,
        content_security_policy={
            'default-src': "'self'",
            'script-src': "'self' 'unsafe-inline' 'unsafe-eval'",
            'style-src': "'self' 'unsafe-inline'",
        },
        force_https=True,
        strict_transport_security=True,
        session_cookie_secure=True
    )
    """
}

# Additional Project-Specific Rules
rule "MEDDPIC analysis" {
    pattern: "class.*MEDDPIC"
    message: "Follow MEDDPIC analysis structure"
    example: """
    class MEDDPICAnalysis:
        def __init__(self, opportunity_data: Dict[str, Any]):
            self.metrics = opportunity_data.get("metrics", {})
            self.economic_buyer = opportunity_data.get("economic_buyer", {})
            self.decision_criteria = opportunity_data.get("decision_criteria", [])
            self.decision_process = opportunity_data.get("decision_process", {})
            self.paper_process = opportunity_data.get("paper_process", {})
            self.implicate_pain = opportunity_data.get("implicate_pain", {})
            self.champion = opportunity_data.get("champion", {})
    """
}

rule "Agent communication" {
    pattern: "class.*Agent"
    message: "Follow agent communication protocol"
    example: """
    class BaseAgent:
        def __init__(self, config: Dict[str, Any]):
            self.config = config
            self.logger = logging.getLogger(self.__class__.__name__)
            
        async def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
            try:
                result = await self._process_impl(data)
                return {"status": "success", "data": result}
            except Exception as e:
                self.logger.error(f"Error processing data: {e}")
                return {"status": "error", "error": str(e)}
    """
}

# Performance Optimization Rules
rule "Caching" {
    pattern: "from functools import lru_cache"
    message: "Use caching for expensive operations"
    example: """
    from functools import lru_cache
    
    @lru_cache(maxsize=100)
    def get_cached_data(key: str) -> Dict[str, Any]:
        return expensive_operation(key)
    """
}

rule "Async operations" {
    pattern: "async def"
    message: "Use async/await for I/O operations"
    example: """
    async def fetch_data(url: str) -> Dict[str, Any]:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()
    """
}

# Testing Standards
rule "Unit tests" {
    pattern: "def test_"
    message: "Write comprehensive unit tests"
    example: """
    def test_process_data():
        # Arrange
        input_data = {"key": "value"}
        expected = {"processed": True}
        
        # Act
        result = process_data(input_data)
        
        # Assert
        assert result == expected
    """
}

rule "Integration tests" {
    pattern: "class Test.*Integration"
    message: "Write integration tests"
    example: """
    class TestMEDDPICOrchestratorIntegration:
        @pytest.fixture
        async def orchestrator(self):
            return MEDDPICOrchestrator()
            
        async def test_full_analysis_flow(self, orchestrator):
            # Test complete analysis flow
            result = await orchestrator.analyze_opportunity({
                "customer": "Test Corp",
                "value": 100000
            })
            assert result["status"] == "success"
    """
} 