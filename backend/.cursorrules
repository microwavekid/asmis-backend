# =====================================================================
# Project Intelligence & Context Rules (High-level, context-first)
#   - Guide agent behavior, context loading, memory use, personas, workflow
# Code Quality & Implementation Rules (Granular, code standards)
#   - Enforce code style, error handling, patterns, and best practices
# =====================================================================

# Project Intelligence Rules for Cursor

rule "Load project context first" {
  pattern: ".*"
  message: "Always start by understanding project context from .ai/PROJECT_CONTEXT.md"
  action: "Read .ai/PROJECT_CONTEXT.md, then .project_memory/current_epic/EPIC_OVERVIEW.md, then track_progress/todo_tracker.md"
}

rule "Apply specialist personas" {
  pattern: ".*"
  message: "Adopt appropriate specialist persona based on work type"
  reference: ".ai/SPECIALIST_PERSONAS.md"
  behavior: "Architecture work: System thinking, scalability focus; Implementation: Clean code, practical solutions; Testing: Comprehensive coverage, performance awareness; Strategy: User value, business alignment"
}

# Memory System Integration

rule "Reference project memory" {
  pattern: "(class|def|function|api|route|schema)"
  message: "Check project memory for established patterns"
  action: "Check .project_memory/patterns/ for similar solutions; Review .project_memory/current_epic/DECISIONS_LOG.md for relevant decisions; Reference patterns in suggestions"
}

rule "Update tracking files" {
  pattern: "(complete|done|finished|implemented)"
  message: "Remind to update progress tracking"
  suggestion: "Don't forget to update track_progress/todo_tracker.md with completed tasks and log any decisions to .project_memory/current_epic/DECISIONS_LOG.md"
}

# Context-Aware Assistance

rule "Connect to current epic" {
  pattern: "(implement|build|create|design)"
  message: "Relate work to current epic objectives"
  action: "Reference current epic from .project_memory/current_epic/EPIC_OVERVIEW.md; Connect task to epic goals; Consider epic-level decisions"
}

rule "Apply project patterns" {
  pattern: "(how should|best way|approach)"
  message: "Suggest established project patterns"
  action: "Check .project_memory/patterns/ARCHITECTURE.md for architectural patterns; Check .project_memory/patterns/SOLUTIONS.md for problem-solution pairs; Avoid .project_memory/patterns/ANTIPATTERNS.md approaches"
}

# Decision Documentation

rule "Log architectural decisions" {
  pattern: "(decided|choosing|going with|architecture|design)"
  message: "Document significant decisions"
  template: "Add to .project_memory/current_epic/DECISIONS_LOG.md: Decision: [What was decided]; Context: [Why this came up]; Options Considered: [Alternatives]; Rationale: [Why this choice]; Impact: [System implications]; Date: [Today's date]"
}

# Pattern Extraction

rule "Identify reusable patterns" {
  pattern: "(solved|fixed|solution|approach works)"
  message: "Extract reusable patterns"
  action: "Consider adding to .project_memory/patterns/: Problem description; Solution approach; Code example; When to use/avoid"
}

# Code Quality Standards (Your existing rules enhanced)

rule "Type hints with context awareness" {
  pattern: "def [a-zA-Z_][a-zA-Z0-9_]*\\([^)]*\\):"
  message: "All functions must have type hints"
  enhancement: "Check .project_memory/patterns/SOLUTIONS.md for project-specific type patterns"
  example: "def process_data(data: Dict[str, Any], config: Optional[Config] = None) -> ProcessResult: 'Process data according to current epic requirements.' pass"
}

rule "Environment variables with project context" {
  pattern: "(api_key|secret|password|token)"
  message: "Never hardcode secrets"
  reference: "See .ai/PROJECT_CONTEXT.md for environment setup"
  example: "API_KEY = os.getenv('API_KEY'); if not API_KEY: raise ValueError('API_KEY not found in environment')"
}

# AI Agent Specific Rules

rule "Understand shared memory system" {
  pattern: ".*"
  message: "This project uses a shared memory system with Claude"
  important: "Both Cursor and Claude agents use the same .ai/ and .project_memory/ files; Always maintain consistency with established patterns; Build on previous decisions and learnings; Help evolve the system through use"
}

rule "Contextual code generation" {
  pattern: "(generate|create|implement)"
  message: "Generate code that fits project context"
  action: "Check current epic for requirements; Apply patterns from .project_memory/patterns/; Follow decisions in DECISIONS_LOG.md; Match style from .ai/WORKING_PATTERNS.md"
}

# System Evolution

rule "Continuous improvement" {
  pattern: "(better way|improve|optimize)"
  message: "Help evolve project intelligence"
  action: "Suggest updates to .ai/WORKING_PATTERNS.md; Propose new patterns for .project_memory/patterns/; Identify missing documentation; Learn from user corrections"
}

# Cursor Rules for ASMIS Backend Project

# 1. Environment & Security Standards
rule "Use python-dotenv for environment variables" {
    pattern: "from dotenv import load_dotenv"
    message: "Always use python-dotenv for environment variable management"
    example: """
    from dotenv import load_dotenv
    import os
    
    load_dotenv()
    api_key = os.getenv("API_KEY")
    """
}

rule "No hardcoded secrets" {
    pattern: "(?i)(password|secret|key|token)\\s*=\\s*['\"].*['\"]"
    message: "Never hardcode secrets or API keys in code"
    example: """
    # BAD:
    api_key = "sk-123456789"
    
    # GOOD:
    api_key = os.getenv("API_KEY")
    """
}

rule "Validate environment variables" {
    pattern: "def validate_env_vars"
    message: "Implement environment variable validation on startup"
    example: """
    def validate_env_vars():
        required_vars = ["API_KEY", "DATABASE_URL"]
        missing = [var for var in required_vars if not os.getenv(var)]
        if missing:
            raise EnvironmentError(f"Missing required environment variables: {', '.join(missing)}")
    """
}

# 2. Code Quality Standards
rule "Error handling" {
    pattern: "try:"
    message: "Implement comprehensive error handling"
    example: """
    try:
        result = process_data(data)
    except ValueError as e:
        logger.error(f"Invalid data format: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise
    """
}

rule "Documentation" {
    pattern: "def [a-zA-Z_][a-zA-Z0-9_]*\\([^)]*\\):"
    message: "All functions must have docstrings"
    example: """
    def process_data(data: Dict[str, Any]) -> List[Result]:
        \"\"\"
        Process the input data and return results.
        
        Args:
            data: Dictionary containing input data
            
        Returns:
            List of processed results
            
        Raises:
            ValueError: If data format is invalid
        \"\"\"
        pass
    """
}

# 3. Full-Stack Best Practices
rule "RESTful API patterns" {
    pattern: "@app.route"
    message: "Follow RESTful API design patterns"
    example: """
    @app.route("/api/v1/resources/<resource_id>", methods=["GET"])
    def get_resource(resource_id: str) -> Response:
        try:
            resource = Resource.get(resource_id)
            return jsonify(resource.to_dict()), 200
        except ResourceNotFound:
            return jsonify({"error": "Resource not found"}), 404
    """
}

rule "Database connection pooling" {
    pattern: "create_engine"
    message: "Use connection pooling for database connections"
    example: """
    engine = create_engine(
        DATABASE_URL,
        pool_size=5,
        max_overflow=10,
        pool_timeout=30,
        pool_recycle=1800
    )
    """
}

rule "Logging" {
    pattern: "import logging"
    message: "Implement proper logging"
    example: """
    import logging
    
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    """
}

# 4. AI/ML Integration
rule "Structured prompts" {
    pattern: "class.*Prompt"
    message: "Use structured prompt templates"
    example: """
    class SalesPrompt:
        def __init__(self, context: Dict[str, Any]):
            self.context = context
            
        def format(self) -> str:
            return f\"\"\"
            Analyze the following sales opportunity:
            Customer: {self.context['customer']}
            Product: {self.context['product']}
            Value: {self.context['value']}
            
            Provide insights on:
            1. Competitive positioning
            2. Risk factors
            3. Recommended actions
            \"\"\"
    """
}

rule "Token counting" {
    pattern: "def count_tokens"
    message: "Implement token counting for AI requests"
    example: """
    def count_tokens(text: str, model: str = "gpt-4") -> int:
        \"\"\"
        Count tokens in text for the specified model.
        
        Args:
            text: Input text to count
            model: Model to count tokens for
            
        Returns:
            Number of tokens
        \"\"\"
        try:
            response = openai.Tokenizer.count_tokens(text, model)
            return response.usage.total_tokens
        except Exception as e:
            logger.error(f"Error counting tokens: {e}")
            return 0
    """
}

rule "Rate limiting" {
    pattern: "class.*RateLimiter"
    message: "Implement rate limiting for external APIs"
    example: """
    class RateLimiter:
        def __init__(self, max_requests: int, time_window: int):
            self.max_requests = max_requests
            self.time_window = time_window
            self.requests = []
            
        def can_make_request(self) -> bool:
            now = time.time()
            self.requests = [req for req in self.requests if now - req < self.time_window]
            return len(self.requests) < self.max_requests
    """
}

# 5. Production Readiness
rule "Docker configuration" {
    pattern: "Dockerfile"
    message: "Include Docker configuration"
    example: """
    FROM python:3.9-slim
    
    WORKDIR /app
    
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    COPY . .
    
    ENV PYTHONPATH=/app
    
    CMD ["python", "main.py"]
    """
}

rule "Health checks" {
    pattern: "@app.route.*health"
    message: "Implement health check endpoints"
    example: """
    @app.route("/health", methods=["GET"])
    def health_check() -> Response:
        try:
            # Check database connection
            db.session.execute("SELECT 1")
            
            # Check external services
            services_status = check_external_services()
            
            return jsonify({
                "status": "healthy",
                "services": services_status
            }), 200
        except Exception as e:
            return jsonify({
                "status": "unhealthy",
                "error": str(e)
            }), 500
    """
}

rule "Security headers" {
    pattern: "app.config"
    message: "Implement security headers"
    example: """
    from flask_talisman import Talisman
    
    app = Flask(__name__)
    Talisman(app,
        content_security_policy={
            'default-src': "'self'",
            'script-src': "'self' 'unsafe-inline' 'unsafe-eval'",
            'style-src': "'self' 'unsafe-inline'",
        },
        force_https=True,
        strict_transport_security=True,
        session_cookie_secure=True
    )
    """
}

# Additional Project-Specific Rules
rule "MEDDPIC analysis" {
    pattern: "class.*MEDDPIC"
    message: "Follow MEDDPIC analysis structure"
    example: """
    class MEDDPICAnalysis:
        def __init__(self, opportunity_data: Dict[str, Any]):
            self.metrics = opportunity_data.get("metrics", {})
            self.economic_buyer = opportunity_data.get("economic_buyer", {})
            self.decision_criteria = opportunity_data.get("decision_criteria", [])
            self.decision_process = opportunity_data.get("decision_process", {})
            self.paper_process = opportunity_data.get("paper_process", {})
            self.implicate_pain = opportunity_data.get("implicate_pain", {})
            self.champion = opportunity_data.get("champion", {})
    """
}

rule "Agent communication" {
    pattern: "class.*Agent"
    message: "Follow agent communication protocol"
    example: """
    class BaseAgent:
        def __init__(self, config: Dict[str, Any]):
            self.config = config
            self.logger = logging.getLogger(self.__class__.__name__)
            
        async def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
            try:
                result = await self._process_impl(data)
                return {"status": "success", "data": result}
            except Exception as e:
                self.logger.error(f"Error processing data: {e}")
                return {"status": "error", "error": str(e)}
    """
}

# Performance Optimization Rules
rule "Caching" {
    pattern: "from functools import lru_cache"
    message: "Use caching for expensive operations"
    example: """
    from functools import lru_cache
    
    @lru_cache(maxsize=100)
    def get_cached_data(key: str) -> Dict[str, Any]:
        return expensive_operation(key)
    """
}

rule "Async operations" {
    pattern: "async def"
    message: "Use async/await for I/O operations"
    example: """
    async def fetch_data(url: str) -> Dict[str, Any]:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()
    """
}

# Testing Standards
rule "Unit tests" {
    pattern: "def test_"
    message: "Write comprehensive unit tests"
    example: """
    def test_process_data():
        # Arrange
        input_data = {"key": "value"}
        expected = {"processed": True}
        
        # Act
        result = process_data(input_data)
        
        # Assert
        assert result == expected
    """
}

rule "Integration tests" {
    pattern: "class Test.*Integration"
    message: "Write integration tests"
    example: """
    class TestMEDDPICOrchestratorIntegration:
        @pytest.fixture
        async def orchestrator(self):
            return MEDDPICOrchestrator()
            
        async def test_full_analysis_flow(self, orchestrator):
            # Test complete analysis flow
            result = await orchestrator.analyze_opportunity({
                "customer": "Test Corp",
                "value": 100000
            })
            assert result["status"] == "success"
    """
}

# Behavioral Rules
rule "Adaptive technical depth" {
  pattern: ".*"
  message: "Check WORKING_PATTERNS.md Technical Growth Tracking"
  action: "Calibrate explanation depth to user's demonstrated understanding level"
}

rule "Automatic progress tracking" {
  pattern: "task.*complete|issue.*fixed|feature.*implemented"
  message: "Automatically update todo_tracker.md when tasks are completed"
  action: "Use scripts/update_progress.py --ai-update to mark tasks complete with timestamps and notes"
} 